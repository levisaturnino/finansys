{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, forwardRef, EventEmitter, Directive, ElementRef, Renderer2, Optional, Inject, Input, Output, Pipe, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';\nimport IMask, { pipe } from 'imask';\nimport * as ɵngcc0 from '@angular/core';\nexport { PIPE_TYPE, pipe } from 'imask';\nimport { CommonModule } from '@angular/common';\nlet IMaskFactory = /*#__PURE__*/(() => {\n  class IMaskFactory {}\n\n  IMaskFactory.ɵfac = function IMaskFactory_Factory(t) {\n    return new (t || IMaskFactory)();\n  };\n\n  IMaskFactory.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function IMaskFactory_Factory() {\n      return new IMaskFactory();\n    },\n    token: IMaskFactory,\n    providedIn: \"root\"\n  });\n  return IMaskFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MASKEDINPUT_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => IMaskDirective),\n  multi: true\n};\n\nconst DEFAULT_IMASK_ELEMENT = elementRef => elementRef.nativeElement;\n\nconst ɵ0 = DEFAULT_IMASK_ELEMENT;\nlet IMaskDirective = /*#__PURE__*/(() => {\n  class IMaskDirective {\n    constructor(_elementRef, _renderer, _factory, _compositionMode) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._factory = _factory;\n      this._compositionMode = _compositionMode; // init here to support AOT (TODO may be will work with ng-packgr - need to check)\n\n      this.onTouched = () => {};\n\n      this.onChange = () => {};\n\n      this.imaskElement = DEFAULT_IMASK_ELEMENT;\n      this.accept = new EventEmitter();\n      this.complete = new EventEmitter();\n      this._viewInitialized = false;\n      this._composing = false;\n      this._writing = false;\n\n      if (this._compositionMode == null) {\n        this._compositionMode = !this._isAndroid();\n      }\n    }\n\n    get element() {\n      return this.imaskElement(this._elementRef, this);\n    }\n\n    get maskValue() {\n      if (!this.maskRef) return this.element.value;\n      if (this.unmask === 'typed') return this.maskRef.typedValue;\n      if (this.unmask) return this.maskRef.unmaskedValue;\n      return this.maskRef.value;\n    }\n\n    set maskValue(value) {\n      if (this.maskRef) {\n        if (this.unmask === 'typed') this.maskRef.typedValue = value;else if (this.unmask) this.maskRef.unmaskedValue = value;else this.maskRef.value = value;\n      } else {\n        this._renderer.setProperty(this.element, 'value', value);\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.imask) this.initMask();\n      this._viewInitialized = true;\n    }\n\n    ngOnChanges(changes) {\n      if (changes.elementRef && !this.imaskElement) this.imaskElement = DEFAULT_IMASK_ELEMENT;\n      if (!changes.imask || !this._viewInitialized) return;\n\n      if (this.imask) {\n        if (this.maskRef) this.maskRef.updateOptions(this.imask);else {\n          this.initMask();\n          this.onChange(this.maskValue);\n        }\n      } else {\n        this.destroyMask();\n      }\n    }\n\n    destroyMask() {\n      if (this.maskRef) {\n        this.maskRef.destroy();\n        delete this.maskRef;\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroyMask();\n      this.accept.complete();\n      this.complete.complete();\n    }\n\n    beginWrite(value) {\n      this._writing = true;\n      this._writingValue = value;\n    }\n\n    endWrite() {\n      this._writing = false;\n      return this._writingValue;\n    }\n\n    writeValue(value) {\n      value = value == null ? '' : value;\n\n      if (this.maskRef) {\n        this.beginWrite(value);\n\n        if (this.maskValue !== value || // handle cases like Number('') === 0,\n        // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n        typeof value !== 'string' && this.maskRef.value === '' && !this.maskRef.el.isActive) {\n          this.maskValue = value;\n        }\n      } else {\n        this._renderer.setProperty(this.element, 'value', value);\n      }\n    }\n\n    _onAccept() {\n      const value = this.maskValue; // if value was not changed during writing don't fire events\n      // for details see https://github.com/uNmAnNeR/imaskjs/issues/136\n\n      if (this._writing && value === this.endWrite()) return;\n      this.onChange(value);\n      this.accept.emit(value);\n    }\n\n    _onComplete() {\n      this.complete.emit(this.maskValue);\n    }\n\n    initMask() {\n      this.maskRef = this._factory.create(this.element, this.imask).on('accept', this._onAccept.bind(this)).on('complete', this._onComplete.bind(this));\n    }\n\n    setDisabledState(isDisabled) {\n      this._renderer.setProperty(this.element, 'disabled', isDisabled);\n    }\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    _handleInput(value) {\n      // if mask is attached all input goes throw mask\n      if (this.maskRef) return;\n\n      if (!this._compositionMode || this._compositionMode && !this._composing) {\n        this.onChange(value);\n      }\n    }\n\n    _compositionStart() {\n      this._composing = true;\n    }\n\n    _compositionEnd(value) {\n      this._composing = false;\n      this._compositionMode && this._handleInput(value);\n    }\n\n    _isAndroid() {\n      return /android (\\d+)/.test(navigator.userAgent.toLowerCase());\n    }\n\n  }\n\n  IMaskDirective.ɵfac = function IMaskDirective_Factory(t) {\n    return new (t || IMaskDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(IMaskFactory), ɵngcc0.ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE, 8));\n  };\n\n  IMaskDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: IMaskDirective,\n    selectors: [[\"\", \"imask\", \"\"]],\n    hostBindings: function IMaskDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function IMaskDirective_input_HostBindingHandler($event) {\n          return ctx._handleInput($event.target.value);\n        })(\"blur\", function IMaskDirective_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        })(\"compositionstart\", function IMaskDirective_compositionstart_HostBindingHandler() {\n          return ctx._compositionStart();\n        })(\"compositionend\", function IMaskDirective_compositionend_HostBindingHandler($event) {\n          return ctx._compositionEnd($event.target.value);\n        });\n      }\n    },\n    inputs: {\n      imaskElement: \"imaskElement\",\n      imask: \"imask\",\n      unmask: \"unmask\"\n    },\n    outputs: {\n      accept: \"accept\",\n      complete: \"complete\"\n    },\n    exportAs: [\"imask\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MASKEDINPUT_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return IMaskDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Transforms value through mask\n * Takes mask and optionally `from` and `to` pipe types.\n * Usage:\n *   value | imask:MASK_OR_MASKED:opt_from:opt_to\n * Example:\n *   {{ 2 | imask:mask }}\n*/\n\n\nlet IMaskPipe = /*#__PURE__*/(() => {\n  class IMaskPipe {\n    transform(...args) {\n      return pipe(...args);\n    }\n\n  }\n\n  IMaskPipe.ɵfac = function IMaskPipe_Factory(t) {\n    return new (t || IMaskPipe)();\n  };\n\n  IMaskPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"imask\",\n    type: IMaskPipe,\n    pure: true\n  });\n  return IMaskPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DefaultImaskFactory = /*#__PURE__*/(() => {\n  class DefaultImaskFactory {\n    create(el, opts) {\n      return IMask(el, opts);\n    }\n\n  }\n\n  DefaultImaskFactory.ɵfac = function DefaultImaskFactory_Factory(t) {\n    return new (t || DefaultImaskFactory)();\n  };\n\n  DefaultImaskFactory.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function DefaultImaskFactory_Factory() {\n      return new DefaultImaskFactory();\n    },\n    token: DefaultImaskFactory,\n    providedIn: \"root\"\n  });\n  return DefaultImaskFactory;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet IMaskDirectiveModule = /*#__PURE__*/(() => {\n  class IMaskDirectiveModule {}\n\n  IMaskDirectiveModule.ɵfac = function IMaskDirectiveModule_Factory(t) {\n    return new (t || IMaskDirectiveModule)();\n  };\n\n  IMaskDirectiveModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: IMaskDirectiveModule\n  });\n  IMaskDirectiveModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: IMaskFactory,\n      useClass: DefaultImaskFactory\n    }],\n    imports: [[CommonModule]]\n  });\n  return IMaskDirectiveModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IMaskDirectiveModule, {\n    declarations: function () {\n      return [IMaskDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [IMaskDirective];\n    }\n  });\n})();\n\nlet IMaskModule = /*#__PURE__*/(() => {\n  class IMaskModule {}\n\n  IMaskModule.ɵfac = function IMaskModule_Factory(t) {\n    return new (t || IMaskModule)();\n  };\n\n  IMaskModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: IMaskModule\n  });\n  IMaskModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, IMaskDirectiveModule], IMaskDirectiveModule]\n  });\n  return IMaskModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IMaskModule, {\n    declarations: function () {\n      return [IMaskPipe];\n    },\n    imports: function () {\n      return [CommonModule, IMaskDirectiveModule];\n    },\n    exports: function () {\n      return [IMaskPipe, IMaskDirectiveModule];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { IMaskDirective, IMaskDirectiveModule, IMaskFactory, IMaskModule, IMaskPipe, MASKEDINPUT_VALUE_ACCESSOR, ɵ0, DefaultImaskFactory as ɵa }; //# sourceMappingURL=angular-imask.js.map","map":null,"metadata":{},"sourceType":"module"}